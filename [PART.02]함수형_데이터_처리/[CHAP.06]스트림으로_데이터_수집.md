# [CHAP.06] 스트림으로 데이터 수집
- 다양한 요소 누적 방식은 `Collector` 인터페이스에 정의
- `collect`와 컬렉터로 구현할 수 있는 질의 예시
  - 통화별로 트랜잭션을 그룹화한 다음, 해당 통화로 일어난 모든 트랜잭션의 합 구하기
  - 트랜잭션을 비싼 트랜잭션과 저렴한 트랜잭션으로 구분하기
  - 트랜잭션을 도시 등 다 수준으로 그룹화
    - 그리고 각 트랜잭션이 비싼지 저렴한지 구분
- `Stream.toList`를 사용하는게 아닌, 
  - 범용적 컬렉터 파라미터를 `collect` 메서드에 전달하여 해결
  - 예시
    ```java
    Map<Currenty, List<Transaction>> transactionsByCurrencies = 
        transactions.stream().collect(groupingBy(Transaction::getCurrency));
    ```

## 6.1. 컬렉터란 무엇인가?
- `Collector` 인터페이스 구현
  - 스트림의 요소를 어떤식으로 도출할지 지정
- `groupingBy`를 활용하여
  - 각 키(통화) bucket 그리고 각 키 버킷에 대응하는 요소 리스트를
  - 값으로 포함하는 `Map`을 만드는 동작 수행
- multilevel으로 그룹화를 수행할 때
  - 명령형 코드에서는 `loop`와 `if`문을 사용한 처리 진행
  - **fp에서는 필요한 컬렉터를 쉽게 추가 가능**

### 6.1.1. 고급 리듀싱 기능을 수행하는 컬렉터
- 훌륭하게 설계된 함수형 API의 또다른 장점
  - 높은 수준의 **조합성**과 **재사용성**
- `collect`로 결과를 수집하는 과정을 **간단**하면서도 **유연한 방식**으로 정의할 수 있음
- 스트림에 `collect`를 호출하면
  - 스트림의 요소에 **컬렉터로 파라미터화된** 리듀싱 연산이 수행됨
- `collect`에서는 리듀싱 연산을 수행하여, 스트림의 각 요소를 방문하면서 컬렉터가 작업 처리 
- 보통 함수를 요소로 변환 할때는 **컬렉터**를 적용하며
  - 최종 결과를 저장하는 자료 구조에 값을 누적
- `Collectors` 유틸리티 클래스는
  - 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 **정적 팩터리 메서드** 제공
  - `toList`
    ```java
    List<Transaction> transactions = transactionSream.collect(Collectors.toList());
    ```

### 6.1.2. 미리 정의된 컬렉터
- `groupingBy` 같이 `Collectors` 클래스에서 제공하는 **팩토리 메서드**의 기능 설명
- `Collectors`에서 제공하는 메서드의 기능(3)
  - 스트림 요소를하나의 값으로 리듀스하고 요약
  - 요소 그룹화
  - 요소 분할
- 리듀싱과 요약 관련 기능을 수행하는 컬렉터
  - 트랜잭션 리스트에서 **트랜잭션 총합**을 찾는 등의 다양한 계산을 수행할 때 이를 컬렉터를 유용하게 활용 가능
- 스트림 요소를 그룹화하는 방법
  - 다수준으로 그룹화 하거나, 각각의 결과 서브 그룹에 **리듀싱 연산** 적용 하도록
  - **다양한 컬렉터**를 조합하는 방법
- **분할**(partitionting)도 가능
  - `한 개의 인수`를 받아 `Boolean`을 반환하는 함수
  - `predicate`를 그룹화 함수로 사용