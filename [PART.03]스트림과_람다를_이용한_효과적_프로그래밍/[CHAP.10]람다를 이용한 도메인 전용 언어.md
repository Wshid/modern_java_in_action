# [CHAP.10] 람다를 이용한 도메인 전용 언어
- DSL(Domain Specific Languages)
- DSL로 어플리케이션의 비즈니스 로직을 표현함으로써,
  - 버그와 오해를 미리 방지할 수 있음
- DSL은 `범용이 아닌` 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어
- DSL은 많은 특성 용어를 사용
  - maven, ant, ...
  - 빌드 과정을 표현하는 DSL
- 예시
  - 메뉴에서 400칼로리 이하의 모든 요리를 찾으시오
    ```java
    while (block != null) {
      read(block, buffer)
      for (every record in buffer) {
        if (record.calorie < 400) {
          System.out.println(record.name);
        }
      }
      block = buffer.next();
    }
    ```
  - 위 코드에는 두 가지 문제를 있음
    - locking, I/O, Disk 할당 같은 여러가지 지식 필요
    - App 수준이 아니라 시스템 수준의 개념을 다루어야 한다는 점
  - 다른 프로그래머는 다음과 같은 sql레벨에서 수정하다는 의견이 있을 수 있음
    ```sql
    SELECT name FROM menu WHERE calorie < 400
    ```
    - java가 아닌 SQL이라는 DSL을 이용해 DB 조작
    - 기술적으로 DSL을 `external`이라 함
    - DB가 텍스트로 구현된 SQL 표현식을 파싱하고 평가하는 API를 제공하는 것이 일반적이기 때문
- **내부적 DSL**과는 차이 존재
- Stream API를 사용한 예시
  ```java
  menu.stream()
      .filter(d -> d.getCalories() < 400)
      .map(Dish::getName)
      .forEach(System.out::println)
  ```
- Stream의 API의 특성인 **메서드 체인**을
  - 보통 자바의 루프의 복잡한 제어와 비교해 유창함을 의미하는 `fluent style`이라고 함
  - 위 예제에서 DSL은 **외부적**이 아니라 **내부적**
- **내부적 DSL**에서는
  - 위에서 언급한 SQL의 `SELECT FROM`구문처럼 애플리케이션 수준의 기본값이
  - 자바 메서드가 사용할 수 있도록 DB를 대표하는 한 개 이상의 **클래스** 형식으로 노출
- 기본적으로 DSL을 만들려면
  - app 수준 프로그래머에 어떤 동작이 필요하며 이들이 어떻게 프로그래머에게 제공하는지 고민 필요
  - 동시에 `시스템 수준`의 개념으로 인해 불필요한 오염이 발생하지 않음
- **내부적 DSL**에서는 유창하게 코드를 구현할 수 있도록
  - 적절하게 클래스와 메서드 노출 과정 필요
- **외부적 DSL**은 DSL 문법 뿐 아니라 `DSL을 평가하는 파서`도 구현해야 함

## 10.1 도메인 전용 언어 
- `DSL`: 특정 비즈니스 도메인의 해결을 위한 언어
  - e.g. 회계 전용 소프트웨어, 입출금 내역, 계좌 통합 같은 개념의 문제를 해결하기 위한 `DSL` 생성 가능
- 특정 비즈니스 도메인을 **인터페이스**로 만든 **API**라고 할 수 있음
- DSL는 **범용 프로그래밍 언어가 아님**
  - 동작, 용어 역시, 특정 **도메인에 국한**되므로
  - 다른 문제는 걱정할 필요가 없으며
  - 자신의 문제에만 집중하면 됨
- DSL을 사용할 경우
  - 특정 도메인의 **복잡성**을 더 잘 다룰 수 있음
- 저수준 구현 세부 사항 메서드는 **클래스**의 **비공개**로 만들어서
  - 저수준 구현 세부 내용을 숨길 수 있음
  - 그럴경우, 사용자 친화적인 `DSL` 생성 가능
- **DSL**과 거리가 먼 특징
  - 평문 **영어**가 아님
  - 도메인 전문가가 **저수준 비즈니스 로직**을 구현하게 만드는 것이 아님
- **DSL**의 두가지 필요성
  - **의사 소통의 왕**
    - 코드의 의도가 명확히 전달되어야 함
    - 프로그래머가 아닌 사람도 이해할 수 있어야 함
    - 코드가 **비즈니스 요구사항**에 부합하는지 확인 가능
  - **한번 코드를 구현하지만 여러번 읽음**
    - **가독성**은 유지보수의 핵심
    - 동료가 쉽게 이해할 수 있도록 코드 구현

### 10.1.1. DSL의 장점과 단점
- **DSL**은 모든 문제의 해결법이 아님
- 특정 도메인에 이용하면, 약이 되거나, 독이 될 수 있음
- DSL은
  - 코드의 **비즈니스 의도**를 명확하게 하고
  - 가독성을 높인다는 점에서 장점
- DSL 구현은
  - **코드**이므로, 올바로 **검증**하고 **유지보수**해야하는 책임이 따름
- **DSL**의 **장점과 비용**을 모두 확인해야
  - DSL을 추가하는 것이
  - 투자대비 긍정적인 결과를 가져올지를 올바로 평가할 수 있음

#### DSL의 장점
- **간결함**
  - API는 비즈니스 로직을 **간편하게 캡슐화**
  - 반복 회피 및 코드 간결화 가능
- **가독성**
  - 도메인 영역의 언어를 사용하므로,
    - `비 도메인 전문가`도 코드를 쉽게 이해할 수 있음
  - 다양한 조직 구성원 간에 **코드**와 **도메인 영역**이 공유될 수 있음
- **유지보수**
  - 잘 설계된 `DSL`로 구현한 코드는, 유지보수하고 바꿀 수 있음
  - 유지보수는 **비즈니스 관련 코드**에 중요
    - 가장 빈번히 변경
- **높은 수준의 추상화**
  - DSL은 `도메인`과 같은 **추상화 수준**에서 동작하므로
  - 도메인의 문제와 직접적으로 연관 되지 않은 **세부 사항을 숨김**
- **집중**
  - 비즈니스 도메인의 규칙을 표현할 목적으로 설계된 언어
  - 프로그래머가 특정 코드에만 집중 가능
- **관심사 분리**
  - 지정된 언어로 `비즈니스 로직`을 표현하므로
  - App의 인프라 구조와 관련된 문제와
    - 독립적으로 비즈니스 관련된 코드에서, 집중하기가 용이
  - 결과적으로 유지보수가 쉬운 코드 구현

#### DSL의 단점
- **DSL 설계의 어려움**
  - 간결하게 제한적인 언어에 **도메인 지식**을 담는 작업 => 어려움
- **개발 비용**
  - 초기 프로젝트에 **많은 비용/시간 소모**
  - 프로젝트에 부담을 주는 요소
- **추가 우회 계층**
  - DSL은 **추가적인 계층**으로 **도메인 모델**을 감싸는 형태
  - 계층을 최대한 작게 만들어 **성능 문제 회피**
- **새로 배워야 하는 언어**
  - DSL을 프로젝트에 추가함으로써, 팀이 배워야 하는 언어가 늘어남 => 부담
- **호스팅 언어 한계**
  - 일부 `java`와 같은 범용 프로그래밍 언어는
    - 장황하고 엄격한 문법을 가짐
  - 사용자 친화적 `DSL`을 만들기 어려움
  - `java 8`에서의 **람다 표현식**은 이 문제를 해결할 강력한 도구