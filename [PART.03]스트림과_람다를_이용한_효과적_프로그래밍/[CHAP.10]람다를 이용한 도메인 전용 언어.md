# [CHAP.10] 람다를 이용한 도메인 전용 언어
- DSL(Domain Specific Languages)
- DSL로 어플리케이션의 비즈니스 로직을 표현함으로써,
  - 버그와 오해를 미리 방지할 수 있음
- DSL은 `범용이 아닌` 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어
- DSL은 많은 특성 용어를 사용
  - maven, ant, ...
  - 빌드 과정을 표현하는 DSL
- 예시
  - 메뉴에서 400칼로리 이하의 모든 요리를 찾으시오
    ```java
    while (block != null) {
      read(block, buffer)
      for (every record in buffer) {
        if (record.calorie < 400) {
          System.out.println(record.name);
        }
      }
      block = buffer.next();
    }
    ```
  - 위 코드에는 두 가지 문제를 있음
    - locking, I/O, Disk 할당 같은 여러가지 지식 필요
    - App 수준이 아니라 시스템 수준의 개념을 다루어야 한다는 점
  - 다른 프로그래머는 다음과 같은 sql레벨에서 수정하다는 의견이 있을 수 있음
    ```sql
    SELECT name FROM menu WHERE calorie < 400
    ```
    - java가 아닌 SQL이라는 DSL을 이용해 DB 조작
    - 기술적으로 DSL을 `external`이라 함
    - DB가 텍스트로 구현된 SQL 표현식을 파싱하고 평가하는 API를 제공하는 것이 일반적이기 때문
- **내부적 DSL**과는 차이 존재
- Stream API를 사용한 예시
  ```java
  menu.stream()
      .filter(d -> d.getCalories() < 400)
      .map(Dish::getName)
      .forEach(System.out::println)
  ```
- Stream의 API의 특성인 **메서드 체인**을
  - 보통 자바의 루프의 복잡한 제어와 비교해 유창함을 의미하는 `fluent style`이라고 함
  - 위 예제에서 DSL은 **외부적**이 아니라 **내부적**
- **내부적 DSL**에서는
  - 위에서 언급한 SQL의 `SELECT FROM`구문처럼 애플리케이션 수준의 기본값이
  - 자바 메서드가 사용할 수 있도록 DB를 대표하는 한 개 이상의 **클래스** 형식으로 노출
- 기본적으로 DSL을 만들려면
  - app 수준 프로그래머에 어떤 동작이 필요하며 이들이 어떻게 프로그래머에게 제공하는지 고민 필요
  - 동시에 `시스템 수준`의 개념으로 인해 불필요한 오염이 발생하지 않음
- **내부적 DSL**에서는 유창하게 코드를 구현할 수 있도록
  - 적절하게 클래스와 메서드 노출 과정 필요
- **외부적 DSL**은 DSL 문법 뿐 아니라 `DSL을 평가하는 파서`도 구현해야 함

## 10.1 도메인 전용 언어 
- `DSL`: 특정 비즈니스 도메인의 해결을 위한 언어
  - e.g. 회계 전용 소프트웨어, 입출금 내역, 계좌 통합 같은 개념의 문제를 해결하기 위한 `DSL` 생성 가능
- 특정 비즈니스 도메인을 **인터페이스**로 만든 **API**라고 할 수 있음
- DSL는 **범용 프로그래밍 언어가 아님**
  - 동작, 용어 역시, 특정 **도메인에 국한**되므로
  - 다른 문제는 걱정할 필요가 없으며
  - 자신의 문제에만 집중하면 됨
- DSL을 사용할 경우
  - 특정 도메인의 **복잡성**을 더 잘 다룰 수 있음
- 저수준 구현 세부 사항 메서드는 **클래스**의 **비공개**로 만들어서
  - 저수준 구현 세부 내용을 숨길 수 있음
  - 그럴경우, 사용자 친화적인 `DSL` 생성 가능
- **DSL**과 거리가 먼 특징
  - 평문 **영어**가 아님
  - 도메인 전문가가 **저수준 비즈니스 로직**을 구현하게 만드는 것이 아님
- **DSL**의 두가지 필요성
  - **의사 소통의 왕**
    - 코드의 의도가 명확히 전달되어야 함
    - 프로그래머가 아닌 사람도 이해할 수 있어야 함
    - 코드가 **비즈니스 요구사항**에 부합하는지 확인 가능
  - **한번 코드를 구현하지만 여러번 읽음**
    - **가독성**은 유지보수의 핵심
    - 동료가 쉽게 이해할 수 있도록 코드 구현

### 10.1.1. DSL의 장점과 단점
- **DSL**은 모든 문제의 해결법이 아님
- 특정 도메인에 이용하면, 약이 되거나, 독이 될 수 있음
- DSL은
  - 코드의 **비즈니스 의도**를 명확하게 하고
  - 가독성을 높인다는 점에서 장점
- DSL 구현은
  - **코드**이므로, 올바로 **검증**하고 **유지보수**해야하는 책임이 따름
- **DSL**의 **장점과 비용**을 모두 확인해야
  - DSL을 추가하는 것이
  - 투자대비 긍정적인 결과를 가져올지를 올바로 평가할 수 있음

#### DSL의 장점
- **간결함**
  - API는 비즈니스 로직을 **간편하게 캡슐화**
  - 반복 회피 및 코드 간결화 가능
- **가독성**
  - 도메인 영역의 언어를 사용하므로,
    - `비 도메인 전문가`도 코드를 쉽게 이해할 수 있음
  - 다양한 조직 구성원 간에 **코드**와 **도메인 영역**이 공유될 수 있음
- **유지보수**
  - 잘 설계된 `DSL`로 구현한 코드는, 유지보수하고 바꿀 수 있음
  - 유지보수는 **비즈니스 관련 코드**에 중요
    - 가장 빈번히 변경
- **높은 수준의 추상화**
  - DSL은 `도메인`과 같은 **추상화 수준**에서 동작하므로
  - 도메인의 문제와 직접적으로 연관 되지 않은 **세부 사항을 숨김**
- **집중**
  - 비즈니스 도메인의 규칙을 표현할 목적으로 설계된 언어
  - 프로그래머가 특정 코드에만 집중 가능
- **관심사 분리**
  - 지정된 언어로 `비즈니스 로직`을 표현하므로
  - App의 인프라 구조와 관련된 문제와
    - 독립적으로 비즈니스 관련된 코드에서, 집중하기가 용이
  - 결과적으로 유지보수가 쉬운 코드 구현

#### DSL의 단점
- **DSL 설계의 어려움**
  - 간결하게 제한적인 언어에 **도메인 지식**을 담는 작업 => 어려움
- **개발 비용**
  - 초기 프로젝트에 **많은 비용/시간 소모**
  - 프로젝트에 부담을 주는 요소
- **추가 우회 계층**
  - DSL은 **추가적인 계층**으로 **도메인 모델**을 감싸는 형태
  - 계층을 최대한 작게 만들어 **성능 문제 회피**
- **새로 배워야 하는 언어**
  - DSL을 프로젝트에 추가함으로써, 팀이 배워야 하는 언어가 늘어남 => 부담
- **호스팅 언어 한계**
  - 일부 `java`와 같은 범용 프로그래밍 언어는
    - 장황하고 엄격한 문법을 가짐
  - 사용자 친화적 `DSL`을 만들기 어려움
  - `java 8`에서의 **람다 표현식**은 이 문제를 해결할 강력한 도구

### 10.1.2. JVM에서 이용할 수 있는 다른 DSL 해결책
- DSL의 **카테고리**를 구분하는 가장 흔한 방법은
  - 마틴 파울러(Martin Fowler)가 소개한 방법으로
  - **내부 DSL**과 **외부 DSL**을 나누는 것
- 내부 DSL(=임베디드 DSL)
  - **순수 자바 코드**와 같은 기존 **호스팅 언어**를 기반으로 구현
- 외부 DSL(standalone)
  - 호스팅 언어와는 **독립적**으로 **자체 문법**을 가짐
- JVM으로 인해 **내부 DSL**과 **외부 DSL**의 중간 카테로기에 해당하는 DSL이 만들어질 가능성이 존재
- `scala`나 `groovy`처럼
  - 자바가 아니지만 `JVM`에서 실행되며
  - 더 유연하고 표현력이 강력한 언어도 있음
- 이들을 **다중 DSL**이라는 **세 번째 카테고리**로 칭함

#### 내부 DSL
- 자바로 구현한 DSL
- **람다 표현식**이 등장하면서,
  - 읽기 쉽고, 간단하고, 표현력있는 DSL 생성 가능
- **동작 파라미터화**를 간단히 만드는데도 쓰임
- 신호 대비 잡음 비율
- 예시 코드
  ```java
  List<String> numbers = Arrays.asList("one", "two", "three");

  // 코드의 잡음 numbers.forEach
  numbers.forEach(new Consumer<String>() {
    @Override
    // 코드의 잡음 accept, System.out.println(s);
    public void accept(String s) {
      System.out.println(s);
    }
  });

  // 람다 표현식으로 개선
  numbers.forEach(s -> System.out.println(s));

  // 메서드 참조로 개선
  numbers.forEach(System.out::println);
  ```
  - 문법상 필요한 **잡음**이 존재
- 사용자가 **기술적인 부분**을 염두해 두고 있다면
  - 자바를 이용하여 `DSL`을 만들 수 있음
- 자바 문법이 문제가 아니라면,
  - **순수 자바**로 `DSL`을 구성하므로, 다음과 같은 장점을 얻을 수 있음

#### 내부 DSL의 장점
- 기존 자바 언어를 활용하기 때문에, **외부 DSL**에 비해 배워야하는 비용이 낮음
- 순수 자바로 DSL을 구현하면, 나머지 코드와 함께 **DSL 컴파일** 가능
  - 다른 언어의 컴파일러를 사용하거나,
  - 외부 DSL을 만드는 도구를 사용할 필요 없음 -> **추가 비용 x**
- `새로운 언어`를 배우거나, `외부 도구`를 배울 필요 없음
- DSL 사용자는 기존의 `Java IDE`를 이용해
  - **자동 완성**, **자동 리팩터링** 같은 기능을 그대로 사용 가능
- 한 개의 언어로 **한 개의 도메인** 또는 **여러 도메인**을 대응하지 못해
  - 추가로 `DSL`을 개발해야하는 상황에서
  - 자바를 이용하면, **추가 DSL**을 쉽게 합칠 수 있음

#### 다중 DSL
- `JVM`에서 실행되는 언어는 100개가 넘음
- `scala, ruby`외에 `JRuby, Jython`등도 존재
- `Kotlin`이나 `Ceylon`과 같이
  - scala와 호환성을 유지하면서, 단순하고 쉽게 배울 수 있는 언어도 존재
  - 위 언어들은 **간편한 문법**을 지향하도록 설계
- `DSL`은 기존 프로그래밍 언어의 영향을 받으므로
  - 간결한 DSL을 만드는데, **새로운 언어의 특성**이 중요
- `scala`은 `currying`, `임의 변환`등
  - `DSL` 개발에 필요한 여러 특성을 갖춤
- 예시: 주어진 함수 `f`를 주어진 횟수만큼 반복 실행
  ```scala
  def times(i: Int, f: => Unit): Unit = {
    f // f 함수 실행
    if ( i > 1) times(i-1, f) // 횟수가 양수면, 횟수를 감소시켜 재귀적으로 times 실행
  }

  // 3번 호출 예시
  times(3, println("Hello World"))
  ```
- `scala`에서는 `i`가 아주 큰 숫자여도, `stack overflow`가 발생하지 않음
  - **꼬리 호출 최적화**를 통해
  - `times` 함수 호출을 `stack`에 추가하지 않기 때문
- 추가 코드
  ```scala
  // `times` 함수를 커링하거나 두 그룹으로 인수를 놓을 수 있음
  def times(i: Int)(f: => Unit): Unit = { f
    if (i > 1) times (i - 1)(f)
  }

  // 여러번 실행할 명령을 `{}`안에 넣어 결과를 얻을 수 있음
  times(3) {
    println("Hello World")
  }
  ```
- `scala`는 함수가 **반복할 인수**를 받는 한 함수를 가지면서
  - `Int`을 익명 클래스로 **암묵적 변환**하도록 정의 가능
  - 코드 예시
    ```scala
    implicit def intToTimes(i: Int) = new { // Int를 `무명 클래스`로 변환하는 `암묵적 변환`을 정의
      def times(f: => Unit): Unit = { // 다른 함수 `f`를 인수로 받는 times 함수 한개만 정의
        def times(i: Int, f: => Unit): Unit = { // 가장 가까운 범주에서 정의한 두 개의 인수를 받는 함수 이용
          f
          if(i > 1) times(i-1, f)
        }
        times(i, f) // 내부 times 함수 호출
      }
    }

    // "Hello World" 세번 출력
    3 times {
      println("Hello World")
    }
    ```
  - 문법적 잡음이 전혀 없으며, 개발자가 아닌 사람도 코드 이해 가능
  - `3`은 컴파일러에 의해 **클래스 인스턴스**로 변환되며 `i`필드에 저장
  - `.`표기법을 이용하지 않고 `times`함수를 호출했는데,
    - 이 때 반복할 함수를 인수로 받음
- 위와 같은 예시는, **자바로 얻기 어려움**

#### 다중 DSL의 단점
- 새로운 프로그래밍 언어를 배우거나, 팀의 누군가가 이미 사용중이어야 함
  - `DSL`을 만드려면, 언어의 **고급 기능**을 활용할 수 있는 충분한 지식이 필요
- `두 개 이상의 언어`가 혼재하므로, 여러 `compiler`로 소스를 빌드하도록, **빌드 과정 개선 필요**
- `JVM`상의 언어도, `java`와의 호환성이 완벽하지 않을 수 있음
  - 호환성 때문에 **성능 손실**도 발생
  - e.g. `scala`와 `java`의 `Collection`은 **상호 호환 되지 않으므로**
    - 상호 컬렉션을 전달하려면, 기존 컬렉션을 대상 언어의 `API`에 맞게 변환 필요

#### 외부 DSL
- 자신만의 문법으로 **새 언어 설계**
- 새 언어를 **파싱**하고, 파서의 결과를 분석하고, 외부 `DSL`을 실행할 코드를 만들어야 함
- 매우 큰 작업
- 이 방법을 택해야 할 경우, `ANTLR`과 같은
  - **자바 기반 파서 생성기**를 이용하면 도움이 됨
- 논리 정연한 프로그래밍 언어를 새로 개발한다는 것은 **간단한 작업이 아님**
- **외부 DSL**을 쉽게 제어 범위를 벗어날 수 있으며
  - 처음 설계한 목적을 벗어나는 경우도 많음
- **무한한 유연성**이 장점
- 필요한 특성에 맞게 언어 구성 가능
- 제대로 언어를 설계하면
  - 비즈니스 문제를 묘사하고 해결하는 제일 좋은 언어 생성 가능
- 자바로 개발한 `인프라 구조의 코드`와 `비즈니스 코드`를 명확하게 분리할 수 있음
  - 하지만 이 분리로, `DSL`과 `호스트 언어`사이의 인공 계층이 생김

## 10.2. 최신 자바 API의 작은 DSL
- `Native Java API`
  - `java 8` 이전의 `Native Java API`는 이미 한 개의 **추상 메서드**를 가진 **인터페이스**를 가지고 있었음
  - `무명 내부 클래스`를 구현하려면, `불필요한 코드`가 추가되어야 함
  - `lambda`와 **메서드 참조**가 등장하면서 게임의 규칙이 바뀌었음
- `java 8`의 `Comparator interface`에 새로운 메서드가 추가됨
- `Compator interface`를 통해 `lambda`가
  - 어떻게 `Native Java API`의 **재사용성**과 **메서드 결합도**를 높였는지 확인
- 예시: `Persons`을 가리키는 객체 목록을 가지고 있음
  - 사람의 나이를 기준으로 **객체**를 정렬한다고 가정
  - `lambda`가 없으면 **내부 클래스**로 `Comparator` 인터페이스를 구현해야 함
  ```java
  Collections.sort(person, new Comparator<Person>() {
    public int compare(Person p1, Person p2) {
      return p1.getAge() - p2.getAge();
    }
  });

  // 내부 클래스를 람다 표현식으로 바꿀 수 있음
  Collections.sort(people, (p1, p2) -> p1.getAge() - p2.getAge());

  // Comparator.comparing method
  Collections.sort(persons, comparing(p -> p.getAge()));

  // lambda를 method 참조로 대신하여 코드 개선
  Collections.sort(persons, comparing(Person::getAge));

  // reverse
  Collections.sort(persons, comparing(Person::getAge).reverse());

  // 이름으로 비교를 수행하는 Comparator를 구현해 같은 나이의 사람들을 알파벳 순으로 정렬
  Coolections.sort(persons, comparing(Person::getAge).thenComparing(Person::getName));

  // List 인터페이스에 추가된 새 sort 메서드를 이용해 코드를 깔끔하게 정리할 수 있음
  persons.sort(comparing(Person::getAge).thenComparing(Person::getName));
  ```
- 위 작은 API는 **컬렉션 정렬 도메인**의 **최소 DSL**
  - **람다**와 **메서드 참조**를 이용한 `DSL`이 코드의 **가독성**, **재가용성**, **결합성**을 높일 수 있는지 보여줌

### 10.2.1. 스트림 API는 컬렉션을 조작하는 DSL
- `Stream` 인터페이스는 `Native Java API`에 작은 **내부 DSL**을 적용한 좋은 예시
- `Stream`은 **컬렉션**의 항목을 `필터, 정렬, 변환, 그룹화, 조작`하는 작지만 강력한 DSL
- 예시: `ERROR`라는 단어로 시작하는 파일의 **첫 40행**을 수집하는 작업을 수행한다고 가정

#### CODE.10.1. 반복 형식으로 예제 로그 파일에서 에러 행을 읽는 코드
```java
List<String> errors = new ArrayList<>();
int errorCount = 0;
BufferedReader bufferedReader = new BufferedReader(new FileReader(fileName));
String line = bufferedReader.readLine();
while (errorCount < 40 && line != null) {
  if (line.startsWith("ERROR")) {
    errors.add(line);
    errorCount++;
  }
  line = bufferedReader.readline();
}
```
- 위 코드는 장황하여 의도를 한 눈에 파악하기 어려움
- 같은 읨루를 지닌 코드가 여러 행에 분산되어 있음
  - `FileReader`가 만들어짐
  - 파일이 종료되었는지 확인하는 `while` 루프의 두 번째 조건
  - 파일의 다음 행을 읽은 `while` 루프의 마지막 행
- 첫 40행을 수집하는 코드도 세 부분
  - `errorCount` 변수를 초기화하는 코드
  - `while` 루프의 첫 번쨰 조건
  - `Error`을 로그에서 발견하면 카운터를 증가시키는 행

#### CODE.10.2. 함수형으로 로그 파일의 에러 행 읽음
```java
List<String> errors = Files.lines(Paths.get(fileName)) // 파일을 열어서 문자열 스트림의 만듦
                           .filter(line -> line.startsWith("ERROR")) // ERROR로 시작하는 행을 필터링
                           .limit(40) // 결과를 첫 40행으로 제한
                           .collect(toList()); // 결과 문자열을 리스트로 수집
```
- `String`은 파일에서 파싱할 행을 의미하여
  - `Files.lines`는 **정적 유틸리티 메서드**로 `Stream<String>`을 반환
  - 파일을 한 행씩 읽은 부분의 코드는 이게 전부
- 마찬가지로 `limit(40)`이라는 코드로 **에러 행**을 `첫 40개`만 수집
- `Stream API`의 `fluent` 형식은 잘 설계된 `DSL`의 또 다른 특징
- 모든 중간 연산은 게으르며,
  - 다른 연산으로 파이프라인될 수 있는 스트림으로 반환
- 최종 연산은 적극적이며 전체 파이프라인이 계산을 일으킴